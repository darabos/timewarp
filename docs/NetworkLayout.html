<html><body><head><title>Timewarp Network Layout</title></head>
<h1>Timewarp Network Layout</h1>
<h4>
This document attempts to plan how networking should work in the GPL project
Star Control: Timewarp (TW).
</h4>
<h3><a name="revision">Revision History:</a></h3>

<h4>[youBastrd! 2002.12.04] Initial creation</h4>

<h3><a name="disclaimer">Disclaimer:</a></h3>

Please don't sue anyone.  Ever.  Especially me.  "Star Control" is a trademark of Accolade; the 
characters, ships, artwork, music and most fans of Star Control's eternal souls are the properties of
Toys For Bob. 


<h3><a name="abstract">Abstract:</a></h3>

TW should be a client-server game, allowing for as many simultaneous clients as
bandwidth and cpu usage will allow.  Clients may connect and disconnect to the
server as often as required.  Various game modes should be available for a 
server.  The server may have the option to run in dedicated or non-dedicated mode,
that is, whether a local player could play on the server itself. In short, it should be 
like other modern multiplayer games like Quake3.<br><br>

The server maintains the game data as the "correct" version of the data, and 
publishes this data to each active client.  Each client transmits packets to 
the server to reflect its player(s)' game choices.  Each client maintains its
own player(s)' data, and will only send information the client perceives the
server needs to know about, and otherwise does not send data.  This is called 
Dead Reckoning, although it'll have to be modified to make sense for TW.  
Unpredictable events generated by the client will be sent to the server.  This 
includes activating weapons, chat messages, and possibly collisions, just to make
sure that the math is done properly.  <br><br>

The server receives packets from clients and checks if the recieved info is 
valid.  If not, it's dropped, and the client may be flagged as cheating (and 
possibly booted now or at some time later).  If it's ok, then it's picked apart,
and the appropriate data is changed.  In any event, the server will send out 
update packets n (=10?) times per second to each client.  However, the server 
will compute what each client needs to see via the Dead Reckoning algorithm, and 
only send packets to a particular client if updates are needed.  This consumes a 
minimal amount of bandwidth: any less would "confuse" clients or lead them to 
misinformation; and more could be redundant.<br><br>

The Dead Reckoning algorithm takes as input for each player the current position, 
velocity and acceleration (or whatever is required for TW); and lag time for this
connection.<br><br>



<h3><a name="interactions">Client/Server Interactions:</a></h3>

This section shows the interactions between clients and a server.  No direct 
communication should take place between clients, yes, that includes chat (see 
char stuff below below).  <br><br>

All communications use UDP, so there is no guarentee that the packets
arrive, except when algorthmically guarenteed.  In such a case, both the sender
and reciever must continue to gather packets and combine them until the message
is complete.  Since this is wasteful in terms of CPU time, such cases are rare 
and the packets short and their sizes known.  These cases are noted MUST ARRIVE.<br><br>

Each packet is prefaced by a FLAG, denoting what type of message this is.  This might be a single
byte or part of a byte, depending how many types of messages there are.  This is based on the
assumption that with smaller UDP packets (&lt;1450 bytes) breaking up packets is rare.  If not,
then we could get, say, the second half of a packet, assume it's the first part, and misinterpret 
its first byte as a FLAG.  <b>If this is a bad assumption, please let me know</b>, because most of
this stuff will break if clients/servers can't determine what kind of message it has just recieved.  We
could have dedicated ports for each type of message.  That might make life easier to code, but marginally
more (difficult to configure) | (make more insecure) firewalls.<br><br>

In any event, the most important data should go first in any packet.<br><br>

Each client may have more than one player physically using it.  I mean, hey, why not, the split screen should
work ok, and depending on the resolution, game type etc, one *view* should suffice.<br><br>

<h4><a name="connections">Connecting to the Server</a></h4><br>

<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
--&gt;<br>
send ping request to server<br>
[sizeof(FLAG)], flag==PING_REQUEST<br>
</tt></td><td><tt>
.<br>
</tt></td></tr>

<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
server replies immediately<br>
[sizeof(FLAG) + sizeof(SERVER_INFO)],<br>
flag==PING_REPLY,<br>
server_info==information maintained by the server about the game
</tt></td></tr></table>

<b>Notes:</b> The server should not reply to an IP address that ends in 255 or 0 to 
prevent DOS flooding.  <b>If this is wrong please tell me/fix this document.</b> 
This is provided to determine if the server is alive and 
if performance will be adequate for the particular client/server combination.  Someday,
a master server system will provide a list of IP addresses of servers.  Then again,
someday I'll have a steady girlfriend.<br><br>
The server maintains information related to the game, such as the number of players 
in the game, the game type, etc.  Such a packet would remain "formed" in the server's 
memory, and simply sent when asked for.  It must be small.  
<br><br><br>


<table width=100% border=1><tr><th>Client</th><th>Server</th></tr><tr>
<td><tt>
--&gt;<br>
Request initial "connection" to the server.<br>
Client is identified by its IP address.<br>
Send version number.<br>
(OPTIONAL) Send a list of game types/mods this client can understand.<br>
[sizeof(FLAG) + sizeof(INITIAL_CONNECTION_STRUCT)], flag==INITIAL_CONNECTION_REQUEST<br>
</tt></td><td><tt>
IP addresses ending in 0 or 255 are dropped.<br>
If IP not already mapped, Server remembers the IP address, and maps a unique ID to the IP address.<br>
</tt></td></tr>

<tr><td><tt>
Remember my ID.
</tt></td><td><tt>
&lt;--<br>
<br>Send ID back.<br>
If the connection is not allowed, a special ID is returned, indicating that the server doesn't want this
client to join right now.  There may be several special values for different circumstances:<br>
ID==RESPONSE_SERVER_FULL means the server is full,<br>
ID==RESPONSE_PING_TOO_HIGH means the pings time for the client/server combo is too high,<br>
ID==RESPONSE_UNKNOWN_GAME_TYPE means the client can't play the game type/mod the server is running 
(we may tack on the name of the game type/mod we're running, and where to get it from), and<br>
ID==RESPONSE_PISS_OFF means the IP has been banned for being a bad boy/girl/zebranski (this might actually be some 
other ID, say, RESPONSE_SERVER_FULL, to hide the fact that they're banned).<br>
[sizeof(FLAG) + sizeof(ID)], flag==INITIAL_CONNECTION_RESPONSE, or<br><br>
[sizeof(FLAG) + sizeof(ID) + sizeof(GAME_TYPE_DESC)], flag==INITIAL_CONNECTION_RESPONSE, 
id==RESPONSE_UNKNOWN_GAME_TYPE, game_type_desc==Game type's name + version + where to get it + description.
</tt></td></tr></table>

<b>Notes:</b> This process prevents abuse from clients forging their IP address.  There are few resources 
allocated by this action, abusive clients will likely run out of IP addresses before the hash runs out 
of IDs, or the server runs out of memory.  This sort of process seems to be manditory these days (this is
called Challenge/Response).<br><br>

The list of game types the client knows is a throwback to the HTTP protocol.  When you tell your browser to
visit yahoo.com, the browser tells yahoo.com what MIME types it's capable of viewing.  If the webpage you're
viewing has, say, a x-application/flash object, but that MIME type isn't in your list of understood types,
the webpage doesn't send the flash object.  This saves the additional communication of asking what the browser
is capable of viewing, as well as saving the HTTP server from remembering anything about the client.  HTTP
is called a Stateless protocol because it doesn't need to remember anything about its clients.<br><br>

In our case, we want a nearly stateless protocol.  We also want to minimize traffic.  As long as the initial
request packet is small enough that it does not get broken up, we're golden.  If it breaks, we've got problems.
Perhaps assigning a short ID to each gametype/mod would make life easier (vs sending the name 
"Cooperative-full-RPG-like-superfun-space-exploration-and-beatdown-game-with-cool-music-and-Syreen-Booty")

<br><br><br>


<table width=100% border=1><tr><th>Client</th><th>Server</th></tr><tr><td><tt>
--&gt;<br>
Send additional connection information, such as the player's name, version, and of course, the ID the
server just handed us.<br>
[sizeof(FLAG) + sizeof(CONNECTION_STRUCT)],<br>
flag==CONFIRMED_CONNECTION_REQUEST,<br>
connection_struct==each player(s)'s multiplayer settings and the client IP's ID<br><br>
</tt></td><td><tt>
Verify that the ID is correct, if it's not, drop the packet.<br>
Unpack the connection_struct, and examine its values.  If any are incorrect, clobber them with
default values.  (not to be trite, but the default values must also be correct!)<br>
Allocate game resources needed by this player/these players.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
Send the game state information.  This means: data about each player, including name, ship, position,
velocity, acceleration, crew, batteries, fleet and other game-type specific info; data related to the game
itself, such as game state (playing, *round* done), *score*, etc.<br>
Since this set of packets has to get there, additional overhead is tolerable.  Since it's likely WAY too much
data to send in one go, breaking it into chunks which are the largest size that guarenteed to make it without
breaking up, and numbering off the packets (like packet 4 of 6)<br>
The last packet must also have a checksum or CRC, or both, for the total data sent.  The client will perform
the check and send back the results.  Once that's happened, the client is up to date and ready to play.<br>
MUST ARRIVE<br>
<br>
[sizeof(FLAG) + sizeof(this_packet) + sizeof(total_packets) + sizeof( *game-state-information*) ], flag==CONFIRMED_CONNECTION_RESPONSE, or <br><br>
[sizeof(FLAG) + sizeof(this_packet) + sizeof(total_packets) + sizeof( *game-state-information*) + sizeof(checksum) + sizeof(CRC) ], flag==CONFIRMED_CONNECTION_RESPONSE,
checksum==sum of all data mod sizeof(checksum), crc==cyclic redundacy check alrogithm results for total data
<br><br>
</tt></td></tr>
<tr><td><tt>
--&gt;<br>
Send Checksum and CRC of all the game data, once they have all been recieved.
[sizeof(FLAG) + sizeof(checksum) + sizeof(CRC)], flag==CONFIRMED_CONNECTION_CHECK_REQUEST
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
Make sure they're ok, if yes, send:<br>
[sizeof(FLAG)], flag==CONFIRMED_CONNECTION_CHECK_RESPONSE<br>
else<br>
either restart sending the state info from scratch (noting that the data has likely changed by now), or 
send<br>
[sizeof(FLAG), flag==CONFIRMED_CONNECTION_CHECK_RESPONE_FAILED]<br>
and the client has to restart the entire process.
</tt></td></tr></table>
<b>Notes</b>: After this process, the client has connected, and knows what the complete game state is.<br><br>
We might track the number of times that the checksum/CRC checks have failed, and only boot the client after
a certain number of failures (maybe 2?).<br><br>

We're assuming that the server will at something > 10 game loops/second, and that as needed, it will send 
game state packets in between what it's doing.  In other words, it will only send one game state packet to
a connecting client per game loop, so that it doesn't get bogged down.<br><br>

To save on FLAG values, CONFIRMED_CONNECTION_CHECK_RESPONE_FAILED might be the same as RESPONSE_SERVER_FULL,
and the client should know what that means at this point.
<br><br><br>


<h4><a name="updating">Updating the Game State</a></h4><br>

The game changes based on event made by choices each player makes and by events that happen based on game logic.
For example, a player fires her Dreadnaught (TM) Thundercannon while pointed at a poor Shofixti(TM).  Her client sends a
message to the server that a shot has been fired, then the server's game logic takes over.  If the little guy
can't get out of the way fast enough (or go out in a Blaze of Glory (TM)), then he's fur on the stellar wind:
another message is sent out from the server to each client that, indeed, the Scout (TM) is done, and Tanaka 
(TM) has more work to do. :)
<br><br>

It gets more complicated though.  Beam weapon and things like the Chejesu's primary should generate events when
they turn on and off, since it may be a few *communications* between the time the button is pressed and released.
This is a tricky topic, and one I wouldn't mind help with.<br><br>

For certain types of projectile weapons, they are fire and forget: when they are fired, a message is sent to 
the server that this projectile should be created at this position, velocity, *power*, etc.  It is solely the
responsiblity of the server to maintain the kinematics of the projectile after this.
Examples: Ur-Quan Primary, Ur-Quan secondary, Spathi fart-cannon<br><br>

Other weapons have different controls, such as the Suppox's strafing ability, or the Chenjesu's primary gun.
It seems we'll have to look at each ship's controls, abilities and effects to make synchronizing the game
work in minimal bandwidth.  With some ships, tapping the key/button to activate an ability might get bandwidth
intensive (ex: Chenjesu main gun).  Generating one event per *activation* toggle or projectile launch might work
when such events are spaced out (in terms of time).  In other cases, tapping might be compressed, putting serveral
events in one update packet, but indicating how spaced out the taps are.<br><br>

Movement is another reason to generate messages.  Using Dead Reckoning, it's possible to plot the expected
course of a ship in a game universe with really good accuracy, and little bandwidth.  Basically, if a ship
doesn't deviate from its course too much, then there's no reason to tell the server about minor course changes.
Similarly, the server, who knows all about the game status, and also knows what each client knows, can decide
if any client needs to know about changes in other ships' courses.  There's some CPU overhead involved in
calculations, and there's some memory requirements.  See, the server has to know what it's last update to a
client was, and extrapolate, based on that info, and how long it's been (possibly plus lag time) if the client
needs an update.  <br><br>

Acceleration is dependent on several things: 
<ol>
<li>a ship using its thrusters</li>
<li>gravity due to a planet</li>
<li>ship effects (Chmrr gravity effect, Druuge firing or hitting)</li>
<li>ship collisions</li>
<li>planet collisions</li>
<li>the Suppox strafing ability</li>
</ol>


<h4><a name="attempt2">Updating Attempt #2</a></h4><br>

If there are sufficient updates, then messages can be short, and limited to just the values that have changed,
instead of every possible value.  There is, of course, overhead involved, both bandwidth and CPU time on the 
server and client.<br>

Smaller update packet:  The idea is that we walk through this entire structure, assuming we start from ship
1 to however many ships there are.  So for 32 ships the minimum number of ship entries is 32.
<ul>
<li>FLAG==UPDATE_GAME_DATA  (1 byte)
<li>Ship entry
  <ul>
	<li>UpdateFlag 
      <ul>
        <li>UPDATE_FLAG_NONE: we don't do anything to this ship
        <li>UPDATE_FLAG_
        <li>
        <li>
        <li>
        <li>
        <li>
        <li>        
      </ul>
	<li>
	<li>
  </ul>
<li>
<li>
<li>
<li>
<li>
</ul>

So, here's the different message types as I see'm.  <b>Please correct my mistakes!</b>  There's bound to 
be lots. :)<br>

<dl>
<dt><dd>
<dt><dd>
<dt><dd>
<dt><dd>
<dt><dd>
<dt><dd>
</dl>





<table width=100% border=1><tr><th>Client</th><th>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>


<table width=100% border=1><tr><th width=50%>Client</th><th width=50%>Server</th></tr><tr><td><tt>
<tr><td><tt>
--&gt;<br>
[]
</tt></td><td><tt>
.
</tt></td></tr>
<tr><td><tt>
.
</tt></td><td><tt>
&lt;--<br>
<br>
[]
</tt></td></tr>
</table>

<b>Notes:</b> 
<br><br><br>










<h4><a name="attempt1">Update attempt 1 -- too big</a></h4><br>

So here's what a ship needs to get updated most often:<br>
<ol>
<li>position, velocity (using floats, in two dimentions, that's 2x4x2 = 16 bytes)</li>
<li>angle (using rounded values 0-127 should be enough = 7 bits)</li>
<li>thrusting (that is, accelerating at the acel rate of the ship) = 1 bit</li>
<li>primary active = 1 bit</li>
<li>secondary active = 1 bit</li>
<li>alive = 1 bit</li>
<li>crew remaining (255 max?) = 1 byte</li>
<li>battery remaining (255 max?) = 1 byte</li>
<li>current target ID (255 ships max? value==0 means no target?) = 1 byte</li>
<li>reserved for game-specific stuff = 2 bytes</li>
<li>ship ID = 1 byte
</ol>

Total size for often-updated data<br>
= 16B + (7b + 1b) + (1b + 1b+ 1b+?) + 1B + 1B + 1B + 2B + 1B<br>
= 24 B<br>
<br>
<br>
For the worst-case scenario of updating ships, every ship has exceeded its Dead Reckoning threshold, and an
update which contains data about all ships (including each clients) is required.  For UDP, the max packet 
payload size that can be safely shipped on the Internet without
fragmenting is 548 B.  So for things like movement only, we have:<br>
548B / 24B = 22.8 ~= 22 clients<br>
<br>
For a server to update the clients:<br>
(22 clients) x (548B payload) + (UDP 28B header)<br>
= 12762 B<br>

To update each client 10 times/second in the worst case scenario, the server must have upload bandwidth:<br>
12762 (B/update) x 10 (update/sec)<br>
= 127 kB / sec
